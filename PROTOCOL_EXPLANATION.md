# Объяснение протокола передачи и маппинга

## Протокол передачи данных: "4 байта + JPEG"

### Зачем нужны 4 байта длины?

Когда мы отправляем бинарные данные через `stdin` (стандартный ввод), данные идут как непрерывный поток байтов. Без информации о длине, Python процесс не знает, где заканчивается один кадр и начинается следующий.

### Формат протокола:

```
[4 байта: длина кадра в big-endian] [JPEG данные]
```

**Пример:**
- Кадр размером 50,000 байт
- Отправляется: `[0x00 0x00 0xC3 0x50]` (50,000 в big-endian) + [50,000 байт JPEG]
- Python читает сначала 4 байта → узнает длину → читает ровно 50,000 байт

### Код отправки (NestJS):

```typescript
// Создаем буфер на 4 байта
const lengthBuffer = Buffer.allocUnsafe(4);
// Записываем длину в big-endian формате
lengthBuffer.writeUInt32BE(frameData.length, 0);

// Отправляем сначала длину, потом данные
pythonProcess.stdin?.write(lengthBuffer);  // 4 байта
pythonProcess.stdin?.write(frameData);     // JPEG данные
```

### Код приема (Python):

```python
# Шаг 1: Читаем 4 байта длины
length_bytes = sys.stdin.buffer.read(4)
frame_length = int.from_bytes(length_bytes, byteorder='big')

# Шаг 2: Читаем ровно frame_length байт JPEG данных
frame_data = b''
while len(frame_data) < frame_length:
    chunk = sys.stdin.buffer.read(frame_length - len(frame_data))
    frame_data += chunk

# Шаг 3: Декодируем JPEG
nparr = np.frombuffer(frame_data, np.uint8)
frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
```

## Как работает маппинг

### 1. Калибровка (один раз при настройке):

Когда пользователь калибрует доску:
- Делается снимок пустой доски
- Определяются 4 угла доски на изображении
- Сохраняются координаты в `{game_token}_mapping.json`

### 2. Применение маппинга (каждый кадр):

```python
# В stream_processor.py, строка 77-78
from improved_board_mapping import apply_mapping
warped = apply_mapping(frame, self.game_token, self.mapping_dir)
```

Что происходит:
1. Загружается JSON с координатами углов доски
2. Применяется перспективное преобразование (warp perspective)
3. Доска выравнивается в прямоугольник фиксированного размера

### 3. Зачем это нужно?

- **Выравнивание**: Доска может быть снята под углом, маппинг выравнивает её
- **Фиксированный размер**: Все кадры имеют одинаковый размер после маппинга
- **Точность**: Легче определить, в какой клетке находится фигура

### Визуализация:

```
Исходный кадр (под углом):          После маппинга (выровненный):
┌─────────────┐                      ┌─────────┐
│    ╱╲       │                      │ ░ ▓ ░ ▓ │
│   ╱  ╲      │  ──маппинг──>        │ ▓ ░ ▓ ░ │
│  ╱    ╲     │                      │ ░ ▓ ░ ▓ │
│ ╱      ╲    │                      │ ▓ ░ ▓ ░ │
└───────────┘                      └─────────┘
```

## Полный поток обработки кадра

```
1. Фронтенд:
   Камера → Canvas → JPEG Blob → Uint8Array → WebSocket

2. Backend (NestJS):
   WebSocket → Buffer → [4 байта длины] + [JPEG данные] → Python stdin

3. Python процесс:
   stdin → [4 байта] → длина → [JPEG данные] → cv2.imdecode → numpy array

4. Обработка:
   numpy array → apply_mapping → выровненная доска → ByteTrack → состояние доски

5. Результат:
   JSON → stdout → NestJS → WebSocket → Фронтенд
```

## Преимущества такого протокола

1. **Эффективность**: Нет overhead от base64 (33% экономии)
2. **Надежность**: Точное разделение кадров по длине
3. **Гибкость**: Поддержка кадров любого размера
4. **Простота**: Легко реализовать и отладить

