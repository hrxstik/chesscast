# Миграция на ByteTrack и WebRTC

## Выполненные изменения

### 1. ✅ Переход на ByteTrack трекинг

#### Изменения в `yolo11_detector.py`:
- ✅ Удален старый `PieceTracker` на основе IoU
- ✅ Добавлен метод `track()` в `YOLO11Detector` для использования встроенного ByteTrack
- ✅ Создан `BoardStateMapper` для преобразования треков в состояние доски
- ✅ ByteTrack работает без начальной позиции - поддерживает произвольную расстановку

#### Изменения в `stream_processor.py`:
- ✅ Удалена инициализация трекера на основе начальной позиции
- ✅ Используется `detector.track()` вместо `detector.predict()` + `tracker.update()`
- ✅ Трекинг работает автоматически между кадрами (`persist=True`)

### 2. ✅ Оптимизация передачи кадров

#### Изменения в `chess-recognition.service.ts`:
- ✅ Поддержка как base64 строк, так и Buffer для обратной совместимости
- ✅ Готовность к переходу на бинарные данные

#### Изменения в `chess-recognition.gateway.ts`:
- ✅ Поддержка приема как строк, так и Buffer

### 3. ✅ Фронтенд компоненты

#### Создан `chess-video-stream.tsx`:
- ✅ Захват видео с камеры через `getUserMedia`
- ✅ Отправка кадров на обработку через WebSocket
- ✅ Отображение видео и виртуальной доски рядом
- ✅ Управление стримингом (старт/стоп)
- ✅ Обработка ошибок

#### Обновлена страница просмотра игры:
- ✅ Интеграция компонента `ChessVideoStream`

## Ответы на вопросы

### 1. ByteTrack в YOLO11
**Да, ByteTrack встроен в YOLO11** и используется через `model.track(tracker='bytetrack.yaml')`.

### 2. BoTSORT в YOLO11
**Да, BoTSORT также доступен** через `tracker='botsort.yaml'`, но ByteTrack используется по умолчанию.

### 3. MOT для произвольной позиции
**Да, с MOT можно определять любую позицию**, но:
- ✅ Трекинг работает без начальной позиции
- ⚠️ Классификация фигур все еще зависит от обученной модели
- ⚠️ Если модель видела только один тип фигур, классификация может быть неточной

### 4. Обучение на нескольких датасетах
**Да, желательно обучать на нескольких датасетах** для:
- Разнообразия фигур (разные шахматные наборы)
- Разных условий освещения
- Разных углов камеры
- Разных досок и фонов

Подробнее см. `MOT_AND_TRAINING.md`

## Архитектура

### Текущая реализация:
1. **Фронтенд**: Захват видео → отправка кадров через WebSocket (base64)
2. **Backend**: Получение кадров → передача в Python процесс → обработка с ByteTrack
3. **Python**: Применение маппинга → трекинг фигур → определение состояния доски → определение хода

### Будущие улучшения:
- [ ] Переход на бинарные данные вместо base64
- [ ] WebRTC медиа-сервер для стриминга видео в реальном времени
- [ ] Оптимизация частоты отправки кадров
- [ ] Кэширование результатов обработки

## Использование

### На фронтенде:
```tsx
import { ChessVideoStream } from '@/components/shared';

<ChessVideoStream gameToken={gameToken} modelPath={optionalModelPath} />
```

### На бэкенде:
Текущая реализация автоматически использует ByteTrack при вызове `detector.track()`.

## Примечания

1. **Base64 пока используется** для обратной совместимости, но код готов к переходу на бинарные данные
2. **WebRTC стриминг** - текущая реализация показывает локальное видео, полноценный WebRTC сервер можно добавить позже
3. **Частота кадров** - установлена на 2 FPS для обработки, можно настроить в `chess-video-stream.tsx`

## Следующие шаги

1. Протестировать ByteTrack на реальных данных
2. Обучить модель на нескольких датасетах
3. Оптимизировать передачу кадров (бинарные данные)
4. Добавить полноценный WebRTC медиа-сервер (опционально)

